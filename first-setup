#Add a new scheduler setting with following event:
#Change telegram chat id below with your own
:global CHATID ("-4936xxx")
#Change telegram bot id below with your own
:global BOTID ("62xxxxxxxx:AAExxxx")
:global GetMacVendor do={
	:do {
		return ([/tool fetch mode=https http-method=get url=("https://api.macvendors.com/".[:pick [:tostr $1] 0 8 ]) as-value output=user ]->"data")
	} on-error={
		return "vendor not found"
	}
}
#source: https://s.id/q4f-O
:global convert do={
  :local Input
  :if ([:len $text] > 0) do={:set Input [ :tostr $text ];} else={:set Input [ :tostr $2 ];}
  :local Return "";
  :if ([ :len $Input ] > 0) do={
    :local Chars
    :local Subs
    :if (($target="urlencode") or ($1 = "urlencode")) do={
      :set Chars " !\"#\$%&'()*+,:;<=>\?@[\\]^`{|}~";
      :set Subs { "%20"; "%21"; "%22"; "%23"; "%24"; "%25"; "%26"; "%27"; "%28"; "%29"; "%2A"; "%2B"; "%2C"; "%3A"; "%3B"; "%3C"; "%3D"; "%3E"; "%3F"; "%40"; "%5B"; "%5C"; "%5D"; "%5E"; "%60"; "%7B"; "%7C"; "%7D"; "%7E" };
    }
    :if (($target="uppercase") or ($1 = "uppercase")) do={
      :set Chars "fteklgxpzwqdchbraunomsiyvj"
      :set Subs {"F";"T";"E";"K";"L";"G";"X";"P";"Z";"W";"Q";"D";"C";"H";"B";"R";"A";"U";"N";"O";"M";"S";"I";"Y";"V";"J"}
    } else={
      :if (($target != "urlencode") and ($1 != "urlencode")) do={
        :set Chars "FTEKLGXPZWQDCHBRAUNOMSIYVJ"
        :set Subs {"f";"t";"e";"k";"l";"g";"x";"p";"z";"w";"q";"d";"c";"h";"b";"r";"a";"u";"n";"o";"m";"s";"i";"y";"v";"j"}
      }
    }
    :put $Chars
    :put $Subs
    :for I from=0 to=([ :len $Input ] - 1) do={
      :local Char [ :pick $Input $I ];
      :local Replace [ :find $Chars $Char ];

      :if ([ :len $Replace ] > 0) do={
        :set Char ($Subs->$Replace);
      }
      :set Return ($Return . $Char);
    }
  }

  :return $Return;
}
:global ConnectionAvailable do={
	:local internet
	/tool flood-ping 8.8.8.8 count=10 do={
		/if ($received > 8) do={
			:set $internet true;
		} else={
			:set internet false;
		}
	}
	:return $internet
}
#This script is inspired by TSOKOTSA's script published in the Mikrotik forum
:global GenerateRandomString do={
	:local hour [:pick [/system clock get time] 0 2]
	:local hourx
	:local minute [:pick [/system clock get time] 3 5]
	:local minutex
	:local second [:pick [/system clock get time] 6 8]
	:local secondx
	:local hundred ("1$second")
	:local hundred2 ("1$minute")
	:local hundred3 ("1$hour")
	:local utsec
	:local uthour
	:local utmin
	:local uptime [/system resource get uptime]
	:if ([:len $uptime] = 10) do={:set utsec [:pick $uptime 8 10]; :set utmin [:pick $uptime 5 7]; :set uthour [:pick $uptime 2 4]}
	:if ([:len $uptime] = 11) do={:set utsec [:pick $uptime 9 11]; :set utmin [:pick $uptime 6 8]; :set uthour [:pick $uptime 3 5]}
	:if ([:len $uptime] = 12) do={:set utsec [:pick $uptime 10 12]; :set utmin [:pick $uptime 7 9]; :set uthour [:pick $uptime 4 6]}
	:if ([:len $uptime] = 8) do={:set utsec [:pick $uptime 6 8]; :set utmin [:pick $uptime 3 5]; :set uthour [:pick $uptime 0 2]}
	:if (([:len $uptime] != 12) and ([:len $uptime] != 10) and ([:len $uptime] != 11) and ([:len $uptime] != 8)) do={
		/log error message="Script error please contact the creator"
	}
	:if (([:pick $hour 1] = [:pick $hour 0]) or ([:pick $minute 1] = [:pick $minute 0]) or ([:pick $second 1] = [:pick $second 0])) do={
		:set hourx (([:pick $hour 1].[:pick $hour 0]) + 1)
		:set minutex (([:pick $minute 1].[:pick $minute 0]) + 1)
		:set secondx (([:pick $second 1].[:pick $second 0]) + 8)
	} else={
		:set hourx ([:pick $hour 1].[:pick $hour 0])
		:set minutex ([:pick $minute 1].[:pick $minute 0])
		:set secondx ([:pick $second 1].[:pick $second 0])
	}
	:if ($hundred2 = $hundred) do={:set hundred2 ($hundred2 + $hour + 1)}
	:if (($hundred3 = $hundred) or ($hundred3 = $hundred2)) do={ :set hundred3 ($hundred3 + $second)}
	:if ($minute + $utsec - $hour < 5) do={
		:set utsec ($utsec + 25)
		:set minute ($minute + 60)
	}
	:local str1 ("fCnR70RysX1MLh8wsqtLqDKHVr0k3QB4vCO04w2tk67moaIyn3Vh5HiQw92c4xlK1VQiDQA0u336O3EMzl3Yde0rL8b5UWKEsBtM5Z3Y2657PWt22w2x584V21dh3zEKzqW6GvY22I1MRYxEv4Y8u8ENqFN5gE1W5kt1HdgeD88jttsNe89X4ZxEMiVAIZS3AW7N5K6gunQNk77gNssfoCuP23JYGE7iG5DS4Uy8ws8rKIO6K2NbBRcm6Mdvfq3PADah6SCBuExd2vHaOOf533royUpEMRJvlreJSUWK5wRPmmlx81iFI6Yr");
	:local str2 ("mA4xx0DJ3EDETaVWfhImu8FU584XjUIttwA29HkmiOmvN2tGmn4GqBcpo0Qp6O838PFc9uZxFwXQ8OKC1aM4X2uojX8E4H555JhFDdYQ9ZsEG8PFXFbbszBAg10COP0Ku2d0tfwT72jXKDnFaDkWMyLUtnQ3l7VhV8eyuaFzVW8h3t55xWvFQrKgoFs842nE5T4qqiT7Ply6YFylrEToTZZNtvw0NkRs3Wcz4qAoEhsE0t6JvHV7e2Y7L7T9c7dZ5JkcF1VAIxpUJ7EQCy62JnxaH1AqSGB49nFI52bhf1UHC2b9UjgXo1VC");
	:local str3 ("4Trr6EncZu6ssMJWe81z8PBpZcy2v58UXgg8m280JxeqGbykd3niaZvY24B3e65FXKkW3yBTTgfV1fII7b8uQURf4FFy7FASbdaEuHfmcpi5l44sb0FO7sQg06MA80LE0l8gJ2k1NzAPTUXJL24Ajvf0ZrvkbMv6VTjMO5lD0Mv5Ljw01w237fKioVn1f2O8eHUq19kMEk1zr5B0ASKLNpL3f0LA3rs18u5jPq7w7VESzhNB89AGFICY72F2ofCs85VDV667CkjmJ0aqg9984I2s5209uu73WXRVc8UMF2PMBEV2J94XFR7c");
	:local string
	:if (($secondx % 2) = 0) do={
		set string $str1
	} else={
		set string $str2
	}
	:if ([:pick $second 1] = [:pick $second 0]) do={
		set string $str3
	}
	:local RandomString
	:set RandomString ([:pick $string ($second + uthour)].[:pick $string ($secondx + $uthour)].[:pick $string ($minute + $utsec - $hour)].[:pick $string ($minute + $uthour + $secondx)].[:pick $string [:tonum ($hundred + $uthour)]].[:pick $string [:tonum ($hundred2 + $utsec)]].[:pick $string [:tonum $hundred3]].[:pick $string ($utmin + $hourx + $second)].[:pick $string ($hourx + $hour + $second)].[:pick $string ($secondx + $utsec)])
	:return $RandomString
}
#source: https://s.id/r5m1E
global UrlEncode;
:set UrlEncode do={
  :local Input [ :tostr $1 ];
  :local Return "";

  :if ([ :len $Input ] > 0) do={
    :local Chars " !\"#\$%&'()*+,:;<=>\?@[\\]^`{|}~";
    :local Subs { "%20"; "%21"; "%22"; "%23"; "%24"; "%25"; "%26"; "%27"; "%28"; "%29";
                  "%2A"; "%2B"; "%2C"; "%3A"; "%3B"; "%3C"; "%3D"; "%3E"; "%3F"; "%40";
                  "%5B"; "%5C"; "%5D"; "%5E"; "%60"; "%7B"; "%7C"; "%7D"; "%7E" };

    :for I from=0 to=([ :len $Input ] - 1) do={
      :local Char [ :pick $Input $I ];
      :local Replace [ :find $Chars $Char ];

      :if ([ :len $Replace ] > 0) do={
        :set Char ($Subs->$Replace);
      }
      :set Return ($Return . $Char);
    }
  }
  :return $Return;
  }
